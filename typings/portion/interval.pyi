"""
This type stub file was generated by pyright.
"""

Atomic = ...

def mergeable(a, b):
    """
    Tester whether two atomic intervals can be merged (i.e. they overlap or
    are adjacent).

    :param a: an atomic interval.
    :param b: an atomic interval.
    :return: True if mergeable, False otherwise.
    """
    ...

class Interval:
    """
    This class represents an interval.

    An interval is an (automatically simplified) union of atomic intervals.
    It can be created with Interval.from_atomic(...) or by passing Interval
    instances to __init__.
    """

    __slots__ = ...
    __match_args__ = ...
    def __init__(self, *intervals) -> None:
        """
        Create a disjunction of zero, one or more intervals.

        :param intervals: zero, one or more intervals.
        """
        ...

    @classmethod
    def from_atomic(cls, left, lower, upper, right):  # -> Self:
        """
        Create an Interval instance containing a single atomic interval.

        :param left: either CLOSED or OPEN.
        :param lower: value of the lower bound.
        :param upper: value of the upper bound.
        :param right: either CLOSED or OPEN.
        """
        ...

    @property
    def left(self):  # -> Literal[Bound.OPEN]:
        """
        Lowest left boundary is either CLOSED or OPEN.
        """
        ...

    @property
    def lower(self):  # -> _PInf:
        """
        Lowest lower bound value.
        """
        ...

    @property
    def upper(self):  # -> _NInf:
        """
        Highest upper bound value.
        """
        ...

    @property
    def right(self):  # -> Literal[Bound.OPEN]:
        """
        Highest right boundary is either CLOSED or OPEN.
        """
        ...

    @property
    def empty(self):  # -> bool:
        """
        True if interval is empty, False otherwise.
        """
        ...

    @property
    def atomic(self):  # -> bool:
        """
        True if this interval is atomic, False otherwise.
        An interval is atomic if it is empty or composed of a single interval.
        """
        ...

    @property
    def enclosure(self):  # -> Self:
        """
        Return the smallest interval composed of a single atomic interval that encloses
        the current interval.

        :return: an Interval instance.
        """
        ...

    def replace(
        self, left=..., lower=..., upper=..., right=..., *, ignore_inf=...
    ):  # -> Self | Any:
        """
        Create a new interval based on the current one and the provided values.

        If current interval is not atomic, it is extended or restricted such that
        its enclosure satisfies the new bounds. In other words, its new enclosure
        will be equal to self.enclosure.replace(left, lower, upper, right).

        Callable can be passed instead of values. In that case, it is called with the
        current corresponding value except if ignore_inf if set (default) and the
        corresponding bound is an infinity.

        :param left: (a function of) left boundary.
        :param lower: (a function of) value of the lower bound.
        :param upper: (a function of) value of the upper bound.
        :param right: (a function of) right boundary.
        :param ignore_inf: ignore infinities if functions are provided (default
            is True).
        :return: an Interval instance
        """
        ...

    def apply(self, func):  # -> Self:
        """
        Apply a function on each of the underlying atomic intervals and return their
        union as a new interval instance

        Given function is expected to return an interval (possibly empty or not
        atomic) or a 4-uple (left, lower, upper, right) whose values correspond to
        the parameters of Interval.from_atomic(left, lower, upper, right).

        This method is merely a shortcut for Interval(*list(map(func, self))).

        :param func: function to apply on each underlying atomic interval.
        :return: an Interval instance.
        """
        ...

    def adjacent(self, other):
        """
        Test if two intervals are adjacent.

        Two intervals are adjacent if they do not overlap and their union form a
        single atomic interval.

        While this definition corresponds to the usual notion of adjacency for atomic
        intervals, it has stronger requirements for non-atomic ones since it requires
        all underlying atomic intervals to be adjacent (i.e. that one
        interval fills the gaps between the atomic intervals of the other one).

        :param other: an interval.
        :return: True if intervals are adjacent, False otherwise.
        """
        ...

    def overlaps(self, other):  # -> bool:
        """
        Test if two intervals overlap (i.e. if their intersection is non-empty).

        :param other: an interval.
        :return: True if intervals overlap, False otherwise.
        """
        ...

    def intersection(self, other):
        """
        Return the intersection of two intervals.

        :param other: an interval.
        :return: the intersection of the intervals.
        """
        ...

    def union(self, other):
        """
        Return the union of two intervals.

        :param other: an interval.
        :return: the union of the intervals.
        """
        ...

    def contains(self, item):  # -> bool:
        """
        Test if given item is contained in this interval.
        This method accepts intervals and arbitrary comparable values.

        :param item: an interval or any arbitrary comparable value.
        :return: True if given item is contained, False otherwise.
        """
        ...

    def complement(self):  # -> Interval:
        """
        Return the complement of this interval.

        :return: the complement of this interval.
        """
        ...

    def difference(self, other):
        """
        Return the difference of two intervals.

        :param other: an interval.
        :return: the difference of the intervals.
        """
        ...

    def __getattr__(self, name):  # -> None:
        ...
    def __len__(self):  # -> int:
        ...
    def __iter__(self):  # -> Generator[Self, Any, None]:
        ...
    def __getitem__(self, item):  # -> Self:
        ...
    def __and__(self, other):  # -> _NotImplementedType | Self:
        ...
    def __or__(self, other):  # -> Self | _NotImplementedType:
        ...
    def __contains__(self, item):  # -> bool:
        ...
    def __invert__(self):  # -> Self:
        ...
    def __sub__(self, other):  # -> _NotImplementedType | Self:
        ...
    def __eq__(self, other) -> bool: ...
    def __lt__(self, other) -> bool: ...
    def __gt__(self, other) -> bool: ...
    def __le__(self, other) -> bool: ...
    def __ge__(self, other) -> bool: ...
    def __hash__(self) -> int: ...
    def __repr__(self):  # -> LiteralString | Literal['()']:
        ...

class AbstractDiscreteInterval(Interval):
    """
    An abstract class for discrete interval.

    This class is not expected to be used as-is, and should be subclassed
    first. The only attribute/method that should be overriden is the `_step`
    class variable. This variable defines the step between two consecutive
    values of the discrete domain (e.g., 1 for integers).
    If a meaningfull step cannot be provided (e.g., for characters), the
    _incr and _decr class methods can be overriden. They respectively return
    the next and previous value given the current one.

    This class is still experimental and backward incompatible changes may
    occur even in minor or patch updates of portion.
    """

    _step = ...
    @classmethod
    def from_atomic(cls, left, lower, upper, right):  # -> Self:
        ...
